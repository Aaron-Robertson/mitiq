---
jupytext:
  text_representation:
    extension: .myst
    format_name: myst
    format_version: 0.13
    jupytext_version: 1.11.1
kernelspec:
  display_name: Python 3 (ipykernel)
  language: python
  name: python3
---

# What additional options are available when using DDD?

Most additional functionality when using DDD with mitiq are accessed through the user provided {mod}`mitiq.ddd.rules` that generates a
sequence from a set of slack windows. We'll discuss three options here, first selecting from the built in rules, then
defining complex rules with the {func}`.general_rule()` and {func}`.repeated_rule()` functions, and then nesting rules to fill long slack
windows first, followed by shorter slack windows.

## Built-in rules
Mitiq provides basic built in rules to approximate the behavior(s) described and discussed in Ref. {cite}`Pokharel_2018_PRL`, through the XX, YY, and XYXY
rules, which generate the corresponding sequences spaced evenly over the input slack window. Within each of these rules, the user may specify a different spacing between
the gates in the sequence and pass the desired spacing as an argument in the high level tools, as before:
```{code-cell} ipython3
from mitiq import ddd, QPROGRAM
from cirq import LineQubit, Circuit, rx, rz, CNOT, X, Y, SWAP, DensityMatrixSimulator, amplitude_damp
from mitiq.interface import convert_to_mitiq
from mitiq.interface.mitiq_cirq import compute_density_matrix
import numpy as np

a, b = LineQubit.range(2)
circuit = Circuit(
    rx(0.1).on(a),
    rz(0.4).on(a),
    rx(-0.72).on(a),
    rz(0.2).on(a),
    rx(-0.8).on(b),
)

def execute(circuit, noise_level=0.1):
    """Returns Tr[ρ |0⟩⟨0|] where ρ is the state prepared by the circuit
    executed with amplitude damping noise.
    """
    # Replace with code based on your frontend and backend.
    mitiq_circuit, _ = convert_to_mitiq(circuit)
    noisy_circuit = mitiq_circuit.with_noise(amplitude_damp(gamma=noise_level))
    rho = DensityMatrixSimulator().simulate(noisy_circuit).final_density_matrix
    return rho[0, 0].real

  
rule = ddd.rules.xx
mitigated_result = ddd.execute_with_ddd(
    circuit=circuit, 
    executor=execute, 
    rule=rule,
    rule_args={"spacing": 0},
)
```

If the user wishes to experiment with creating other rules, a {func}`.general_rule()` is provided, which takes a list of gates and spacing. As an example,
Let's define a rule function that will generate an _XXYY_ sequence:
```{code-cell} ipython3
def xxyy(slack_length: int, spacing: int = -1) -> Circuit:
    xxyy_sequence = ddd.general_rule(
        slack_length=slack_length,
        spacing=spacing,
        gates=[X, X, Y, Y],
    )
    return xxyy_sequence
```
A rule defined in this manner can similarly be used throughout high-level functions.

## Complex rules

To create a rule that repeats without idle moments, we can use the {func}`.repeated_rule()` abstraction to fill each moment in the 
slack window with repetitions of the provided sequence. Adapting the circuit used in [How do I use DDD?](ddd-1-intro.myst) to increase slack length we can
repeat the sequence as follows:

```{code-cell} ipython3
from cirq import CNOT, X, Y
a, b = LineQubit.range(2)
circuit_one = Circuit(
    rx(0.1).on(a),
    rx(0.1).on(a),
    rz(0.4).on(a),
    rx(-0.72).on(a),
    rz(0.2).on(a),
    rx(0.1).on(a),
    rx(0.1).on(a),
    rz(0.4).on(a),
    rx(-0.72).on(a),
    rz(0.2).on(a),
    rx(-0.8).on(b),
    CNOT.on(a, b),
)

print(circuit_one)

def custom_rule(slack_length: int)->Circuit:
   return ddd.rules.repeated_rule(slack_length=slack_length, gates=[X, Y, X, Y])
```

When {func}`.execute_with_ddd()` is called with the inputs above, it executes the following circuit:
```{code-cell} ipython3
ddd.insert_ddd_sequences(circuit_one, custom_rule)
```

## Nested rules

Finally, as demonstrated in detail in the following user guide section, {func}`.insert_ddd_sequences()` is all one needs to apply DDD.
Therefore, supposing a user wants to mix sequences, where _XYXY_ is applied first to long slack windows then _XX_ to ones shorter
than the 4 moment minimum for _XYXY_.

In this case, one needs only insert the longer sequence first, then apply DDD as in the default case:
```{code-cell} ipython3
from cirq import SWAP
qreg = LineQubit.range(8)
x_layer = Circuit(X.on_each(qreg))
cnots_layer = Circuit(SWAP.on(q, q + 1) for q in qreg[:-1])
circuit = x_layer + cnots_layer + x_layer
print(circuit)

long_rule = ddd.rules.xyxy
short_rule = ddd.rules.xx
modified_circuit = ddd.insert_ddd_sequences(circuit, rule=long_rule)
mitigated_result = ddd.execute_with_ddd(
    circuit=modified_circuit, 
    executor=execute, 
    rule=short_rule,
)
```

This above mitigation flow executes the following circuit:
```{code-cell} ipython3
ddd.insert_ddd_sequences(circuit, rule=short_rule)
```
